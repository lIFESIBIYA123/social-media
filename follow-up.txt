
# ================================================================================
# THIS ARE THE STEPS I USED AS SUMMARY
==================================================================================

========= 1. create the data base and connect it to django ========

    DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'coredb',
        'USER': 'core',
        'PASSWORD': 'Gershom@sibiya123',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}

========= 2. install an http request client ========
    NB for APIs
    use = insomnia
    To download a version of Insomnia that suits your OS, go to the following page: https://
    insomnia.rest/download.

    __________________________________________________________
    QUESTIONS TO ANSWER
    __________________________________________________________
        Questions
        1. What is a REST API?
        2. What is Django?
        3. How to create a Django project?
        4. What are migrations?
        5. What is a virtual environment in Python?


========= 3.Authentication and Authorization using JWTs ========

    topics in this chapter:
    • Understanding JWTs
    • Organizing a project
    • Creating a user model
    • Writing the user registration feature
    • Adding the login feature
    • Refresh logic

    JWT
    stands for JSON Web Token. It’s one of the most used means of authentication in web applications 
    but also helps with authorization and information exchanges.

    Each time a user successfully logs in, a JWT is created and returned. The JWT will be represented as 
        credentials used to access protected resources. The fact that it’s possible to store data in a JWT makes 
    it vulnerable. That’s why you should specify an expiration time when creating a JWT.

    we’ll be using JWTs in two ways. To make it simple, we’ll have two types of tokens:
    • An access token: Used to access resources and handle authorization
    • A refresh token: Used to retrieve a new access token

    no user wants the login page to appear every 5 minutes.
    That’s where a refresh token is useful. It’ll contain the essential information needed to verify the user 
    and generate a new access token.

    1. At the root of the project, run the following command:
        django-admin startapp core

            core/apps.py
            from django.apps import AppConfig

            class CoreConfig(AppConfig):
                default_auto_field = 'django.db.models.BigAutoField'
                name = 'core'
                label = 'core'

        Register the apps in the setting.py file of the project:

    2. run the following command:c
        cd core
        django-admin startapp user


    .3. file core/user/models.py

                from django.db import models
                import uuid
                from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
                from django.core.exceptions import ObjectDoesNotExist
                from django.db import models
                from django.http import Http404


                class User(AbstractBaseUser, PermissionsMixin):
                    public_id = models.UUIDField(db_index=True, unique=True, default=uuid.uuid4, editable=False)
                    username = models.CharField(db_index=True, max_length=255, unique=True)
                    first_name = models.CharField(max_length=255)
                    last_name = models.CharField(max_length=255)
                    email = models.EmailField(db_index=True, unique=True)
                    is_active = models.BooleanField(default=True)
                    is_superuser = models.BooleanField(default=False)
                    created = models.DateTimeField(auto_noe=True)
                    updated = models.DateTimeField(auto_now_add=True)


                    USERNAME_FIELD = 'email'
                    REQUIRED_FIELDS = ['username']

                    objects = UserManager()

                    def __str__(self):
                        return f"{self.email}"

                    @property
                    def name(self):
                        return f"{self.first_anme} {self.last_name}"




                # Creating the user and superuser

                class UserManager(BaseUserManager):
                    def get_object_by_public_id(self, public_id):
                        try:
                            instance = self.get(public_id=public_id)
                            return instance
                        except (ObjectDoesNotExist, ValueError, TypeError):
                            return Http404


                    def create_user(self, username, email, password=None, ***args, **kwargs):
                        """create and return a `user` with an email, phone number, username and password."""

                        if username is None:
                            raise TypeError('Users must have a username')

                        if email is None:
                            raise TypeError('User must have an email.')
                        
                        if password is None:
                            raise TypeError('User must have a password.')

                        user = self.model(username=username, email=self.normal(email), **kwargs)
                        user.set_password(password)
                        user.save(using=self._db)

                        return user

                    def create_supersuser(self, username, email, password, **kwargs):
                        """Create and return a `User` with superuser (admin) permissions """

                        if password is None:
                            raise typeError('superuser must have a password')

                        if email is None:
                            raise TypeError('Superuser must have an email.')

                        if username is None:
                            raise TypeError('Superuser must have a username.')

                        user = self.create_user(username, email, password, **kwargs)
                        user.is_superuser = True
                        user.is_staff = True
                        user.save(using=self._db)

                        return user

    4. et’s rewrite the apps.py file of the user. It contains the app configs that Django will use to 
        locate the application. Let’s also add a label for the application:

            core/user/apps.py

            from django.apps import AppConfig
            class UserConfig(AppConfig):
                default_auto_field = 'django.db.models.BigAutoField'
                name = '.core.user'
                label = 'core_user'


    5. t’s register the application now in the INSTALLED_APPS setting

                    ...
            'core',
            'core.user'
            ]

    6. We also need to tell Django to use this User model for the authentication user model. In the 
        settings.py file, add the following line:

        CoreRoot/settings.py
        AUTH_USER_MODEL = 'core_user.User'
        Great – we can now create the first migration for the user app:
        python manage.py makemigrations

        then run:

        python manage.py migrate


    7. writng User serializer, to handle complex data

         7.1 A serializer allows us to convert complex Django complex data structures such as QuerySet or model 
            instances into Python native objects that can be easily converted to JSON or XML format

            Django Rest Framework (DRF) provides a 
            serializers package you can use to write serializers and also validations when API calls are made 
            to an endpoint using this serializer.

            (a) pip install djangorestframework django-filter

                    requirements.txt:

                    Django==4.0.1
                    psycopg2-binary==2.9.3
                    djangorestframework==3.13.1
                    django-filter==21.1

            (b)  We are also adding django-filter for data filtering support. Let’s add rest_framework to 
                    the INSTALLED_APPS setting:
                    CoreRoot/settings.py
                    INSTALLED_APPS = [
                    ...
                    'rest_framework',
                    ]

            (c) In the core/user directory, create a file called serializers.py. This file will contain the 
                A serializer converts complex data types (like Django models) into JSON format for API responses, 
                and validates/converts JSON back into Python objects for database operations. 
                It's the bridge between your database models and API endpoints, handling data transformation
                 and validation automatically.
                
                core/user/serializers.py
                UserSerializer class:

                from rest_framework import serializers
                from core.models import User

                class UserSerializer(serializers.ModelSerializer):
                    id = serializers.UUIDField(source='public_id',
                    read_only=True, format="hex")
                    created = serializers.DateTimeField(read_only=True)
                    updated = serializers.DateTimeField(read_only=True)

                    class Meta: 
                        model = User
                        fields = ['id', 'username', 'first_name',
                            'last_name', 'bio', 'avatar', 'email',
                            'is_active', 'created', 'updated']
                        read_only_fields = ['is_active']

    8. Writing UserViewset
        As we know, Django at its core is based on the Model-View-Template (MVT) architecture. The 
        model communicates with the views (or controllers) and the template displays responses or redirects 
        requests to the views

        As we know, Django at its core is based on the Model-View-Template (MVT) architecture. The 
        model communicates with the views (or controllers) and the template displays responses or redirects 
        requests to the views

        a viewset is simply a class-based view that can 
        handle all the basic HTTP requests—GET, POST, PUT, DELETE, and PATCH—without hardcoding 
        any CRUD logic here.

        Let’s write the viewset. Inside the user directory, rename the view file viewsets.py and add 
        the following content:
        core/user/viewsets.py

        from rest_framework.permissions import AllowAny
        from rest_framework import viewsets
        from core.user.serializers import UserSerializer
        from core.user.models import User

        class UserViewSet(viewsets.ModelViewSet):
            http_method_names = ('patch', 'get')
            permission_classes = (AllowAny,)
            serializer_class = UserSerializer

            # gets the list of all users
            def get_queryset(self):
                if self.request.user.is_superuser:
                    return User.objects.all()
                return User.objects.exclude(is_superuser=True)

            # get one user
            # This method is called when 
            # a GET or PUT request is made on the /user/id/ endpoint, with id representing the ID of 
            # the user.

            def get_object(self):
                obj = User.objects.get_object_by_public_id(self.kwargs['pk'])
                self.check_object_permissions(self.request, obj)
                return obj

            # There we have the User viewset – but there is no endpoint yet to make it work. Well, let’s add a 
            # router now.

    9. Adding a router
        Routers allow you to quickly declare all of the common routes for a given controller; the next code 
        snippet shows a viewset to which we will be adding a router.
        At the root of the apps project (core), create a file named routers.py.
        And let’s add the code:

        core/router

        from rest_framework import routers
        
        from core.user.viewsets import UserViewSet

        router = routers.SimpleRouter()

        # ====================================
        # USER ROUTES
        # ====================================
        router.register(r'user', UserViewSet, basename='user')

        urlpatterns = [
            *router.urls,
        ]

        9.1 add the router path in coreRoot/urls.py

            rom django.contrib import admin
            from django.urls import path, include
            from core.routers import router

            urlpatterns = [
                path('admin/', admin.site.urls),
                path('api/', include(router.urls)),
            ]

        9.2 making permissions so tht not can edit someone's data
            change the permission on the permission_classes attribute in the 
            UserViewSet class:
            core/user/viewsets.py
            replace AllowAny with IsAuthenticated 

    10. Writing the user registration feature

        To make things simpler, if the registration of a user is successful, we will provide credentials, here 
        JWTs, so the user won’t have to log in again to start a session – a win for user experience.
        First, let’s install a package that will handle JWT authentication for us. 
        The djangorestframeworksimplejwt package is a JWT authentication plugin for DRF:

        pip install djangorestframework-simplejwt
        The package covers the most common use case of JWT
        register the app in INSTALLED_
        APPS and specify DEFAULT_AUTHENTICATION_CLASSES in the REST_FRAMEWORK dict:

        …
        # external packages apps
            'rest_framework',
            'rest_framework_simplejwt',
            'core',
            'core.user'
        ]
        ...
        REST_FRAMEWORK = {
            'DEFAULT_AUTHENTICATION_CLASSES': (
                'rest_framework_simplejwt.authentication
                 .JWTAuthentication',
            ),
            'DEFAULT_FILTER_BACKENDS':
                'django_filters.rest_framework.DjangoFilterBackend'],
        }

    create ne app called auth in the coer appear

    cd core && django-admin startapp auth:
        New-Item -Path "core/auth" -ItemType Directory -Force
        python -m django startapp auth core/auth

        core/auth/apps.py
        rewrite apps.py | label = 'core_auth' name = 'core.auth'

        coreRoot/settings.py installed apps add:
        'core.auth' 
        

    Create a Python package called serializers and another one called viewsets. 
    make sure that these new directories have an __init__.py file

    Inside the serializers directory, create a file called register.py
    core/auth/serializers/register.py

    from rest_framework import serializers
    from core.user.serializers import UserSerializer
    from core.user.models import User


    class RegisterSerializer(UserSerializer):
        """
            Registration serializer for requests and user creation
        """

        # making sure the password is at least 8 characters long and no longer
        # than 128 and cant be  read by the user

        password = serializers.CharFields(max_length=128, min_length=8, write_only=True, required=True)

        class Meta:
            model = User
            # list of all the fields that can be included in a response
            fields = ['id', 'bio', 'avatar', 'email', 'username', 'first_name',
                        'last_name', 'password']

        def create(self, validated_data):
            # Use the `create_user` method we wrote earlier for the UserManger to create 
            # a user.


            return User.objects.create_user(**validated_data)

            ==================================================================================


        11. Next, we can add the viewset and register it in the register.py file:
            core/auth/viewsets/register.py

            from rest_framework.response import Response
            from rest_framewor.viewsets import ViewSet
            from rest_framework.permissions import AllowAny
            from rest_framework import status
            from rest_frameworksimplejwt.tokens import RefreshToken
            from core.auth.serializers import RegisterSerializer

            class RegisterViewSet(ViewSet):
                serializer_class = RegisterSerializer
                permission_classes = (AllowAny,)
                http_method_names = ['post']

                def create(self, request, *args, **kwargs):
                    serializer = self.serializer_class(data=request.data)
                    serializer.is_valid(raise_exception=True)
                    user = serializer.save()
                    refresh = RefreshToken.for_user(user)
                    res = {
                        "refresh": str(refresh),
                        "access": str(refresh.access_token),
                    }

                    return Response ({
                        "user": serializer.data,
                        "refresh": res["refresh"],
                        "token": res["access"]
                    }, status=status.HTTP_201_CREATED)

    ==============================================================================================

        we are using attributes from the ViewSet class. We are also 
        rewriting the create method to add access and refresh tokens in the body of the response. The 
        djangorestframework-simplejwt package provides utilities we can use to directly generate 
        tokens. That’s what RefreshToken.for_user(user) does.


        12. final step – let’s register the viewset in the routers.py file:

            CORE/ROUTER.PY

            router.register(r'auth/register', RegisterViewSet, basename='auth-register')
            
    ========================================================================================
        NB dont forget to inport these in __init__.py
            from .register import RegisterViewSet

        Great! Let’s test the new endpoint with Insomnia. In the collection of requests for this project, create 
        a new POST request. The URL will be as follows: localhost:8000/api/auth/register/.
        As a body for the request, you can pass the following:
        {
        "username": "mouse21",
        "first_name": "Mickey",
        "last_name": "Mouse",
        "password": "12345678",
        "email": "mouse@yopmail.com"
        }

================================================================================
===============================================================================
    13. adding the login feature

        The login feature will require the email or the username with the password. Using the 
        djangorestframework-simplejwt package, which provides a serializer called 
        TokenObtainPairSerializer, we’ll write a serializer to check for user authentication but also 
        return a response containing access and refresh tokens. For this, we will rewrite the validate method 
        from the TokenObtainPairSerializer class. Inside the core/auth/serializers
        directory, create a new file called login.py (this file will contain LoginSerializer, a subclass 
        of TokenObtainPairSerializer):

        core/auth/serializers/login.py

        from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
        from rest_framework_simplejwt.settings import api_settings
        from django.contrib.auth.models import update_last_login
        from core.user.serializers import UserSerializer

        class LoginSerializer(TokenObtainPairSerializer):
            """
                Login serializer for requests and user authentication
            """

            def validate(self, attrs):
                data = super().validate(attrs)

                refresh = self.get_token(self.user)

                data['user'] = UserSerializer(self.user).data
                data['refresh'] = str(refresh)
                data['access'] = str(refresh.access_tpken)

                if api_settings.UPDATE_LAST_LOGIN:
                    update_last_login(None, self.user)

                return data

        ==========================================================================================
        That’s why super is helpful here. It’s a built-in method in Python that returns 
        a temporary object that can be used to access the class methods of the base class.
        ==========================================================================================

        core/auth/serializers/__init__.py

        code:
            from .register import RegisterSerializer
            from .login import LoginSerializer

        ==========================================================================================

        14. The next step is to add the viewset. We’ll call this viewset LoginViewset. As we are not directly 
            teracting with a model here, we’ll just be using the viewsets.ViewSet class:

            core/auth/viewsets/login.py

        code:
            from rest_framework.response import Response
            from rest_framework.viewsets import ViewSet
            from rest_framework.permissions import AllowAny
            from rest_framework import status
            from rest_framework_simplejwt.exceptions import TokenError, InvalidToken    
            from core.auth.serializers import LoginSerializer

            class LoginViewSet(ViewSet):
                serializer_class = LoginSerializer
                permission_classes = (AllowAny,)
                http_method_names = ['post']

                def create(self, request, *args, **kwargs):
                    serializer = self.serializer_class(data=request.data)
                    try:
                        serializer.is_valid(raise_exception=True)

                    except TokenError as e:
                        raise InvalidToken(e.args[0])

                    return Response(serializer.validated_data, status=status.HTTP_200_OK)

            =================================================================================

         14.   Add the viewset to the __init__.py file of the viewsets directory:
         code:
            from .register import RegisterViewSet
            from .login import LoginViewSet
        ======================================================================================

        We can now import it and register it in the routers.py file:
        core/routers.py
        code:
            router.register(r'auth/login', LoginViewSet, basename='auth-login')
            
    =========================================================================================

        14. Refresh logic
        In auth/viewsets, add a new file called refresh.py:
        core/auth/viewsets/refresh.py

        code:
            from rest_framework.response import Response
            from rest_framework_simplejwt.views import TokenRefreshView
            from rest_framework.permissions import AllowAny
            from rest_framework import status
            from rest_framework import viewsets
            from rest_framework_simplejwt.exceptions import TokenBackendError, InvalidToken

            class RefreshViewSet(viewsets.ViewSet, TokenRefreshView):
                permission_casses = (AllowAny,)
                http_method_names = ['post']

                def create(self, request, *args, **kwargs):
                    serializer = self.get_serializer(data=request.data)

                    try:
                        serializer.is_valid(raise_exxception=True)

                    except TokenError as e:
                        raise InvalidToken(e.args[0])

                    return Response(serializer.validated_data, status=status.HTTP_200_OK)

    ===========================================================================================
    Now add the class in the __init__.py file.
    from .register import RegisterViewSet
    from .login import LoginViewSet
    from .refresh import RefreshViewSet
    
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    And now register it in the routers.py file
    core/routers.py
    code:
        from core.auth.viewsets import RegisterViewSet,
        LoginViewSet, RefreshViewSet
        ...
        router.register(r'auth/refresh', RefreshViewSet,
        basename='auth-refresh')
----------------------------------------------------------------------------------------------------------
Summary
In this chapter, we learned how to write an authentication system based on JWT for a Django application 
using DRF and djangorestframework-simplejwt. We also learned how to extend classes 
and rewrite the functions.
In the next chapter, we’ll add the posts feature. Our users will be able to create a post that can be 
viewed and liked by other users.
Questions
1. What is a JWT?
2. What is Django Rest Framework?
3. What is a model?
4. What is a serializer?
5. What is a viewset?
6. What is a router?
7. What is the usage of a refresh token?

_________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________

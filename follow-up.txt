
# ================================================================================
# THIS ARE THE STEPS I USED AS SUMMARY
==================================================================================

========= 1. create the data base and connect it to django ========

    DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'coredb',
        'USER': 'core',
        'PASSWORD': 'Gershom@sibiya123',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}

========= 2. install an http request client ========
    NB for APIs
    use = insomnia
    To download a version of Insomnia that suits your OS, go to the following page: https://
    insomnia.rest/download.

    __________________________________________________________
    QUESTIONS TO ANSWER
    __________________________________________________________
        Questions
        1. What is a REST API?
        2. What is Django?
        3. How to create a Django project?
        4. What are migrations?
        5. What is a virtual environment in Python?


========= 3.Authentication and Authorization using JWTs ========

    topics in this chapter:
    • Understanding JWTs
    • Organizing a project
    • Creating a user model
    • Writing the user registration feature
    • Adding the login feature
    • Refresh logic

    JWT
    stands for JSON Web Token. It’s one of the most used means of authentication in web applications 
    but also helps with authorization and information exchanges.

    Each time a user successfully logs in, a JWT is created and returned. The JWT will be represented as 
        credentials used to access protected resources. The fact that it’s possible to store data in a JWT makes 
    it vulnerable. That’s why you should specify an expiration time when creating a JWT.

    we’ll be using JWTs in two ways. To make it simple, we’ll have two types of tokens:
    • An access token: Used to access resources and handle authorization
    • A refresh token: Used to retrieve a new access token

    no user wants the login page to appear every 5 minutes.
    That’s where a refresh token is useful. It’ll contain the essential information needed to verify the user 
    and generate a new access token.

    1. At the root of the project, run the following command:
        django-admin startapp core

            core/apps.py
            from django.apps import AppConfig

            class CoreConfig(AppConfig):
                default_auto_field = 'django.db.models.BigAutoField'
                name = 'core'
                label = 'core'

        Register the apps in the setting.py file of the project:

    2. run the following command:c
        cd core
        django-admin startapp user


    .3. file core/user/models.py

                from django.db import models
                import uuid
                from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
                from django.core.exceptions import ObjectDoesNotExist
                from django.db import models
                from django.http import Http404


                class User(AbstractBaseUser, PermissionsMixin):
                    public_id = models.UUIDField(db_index=True, unique=True, default=uuid.uuid4, editable=False)
                    username = models.CharField(db_index=True, max_length=255, unique=True)
                    first_name = models.CharField(max_length=255)
                    last_name = models.CharField(max_length=255)
                    email = models.EmailField(db_index=True, unique=True)
                    is_active = models.BooleanField(default=True)
                    is_superuser = models.BooleanField(default=False)
                    created = models.DateTimeField(auto_noe=True)
                    updated = models.DateTimeField(auto_now_add=True)


                    USERNAME_FIELD = 'email'
                    REQUIRED_FIELDS = ['username']

                    objects = UserManager()

                    def __str__(self):
                        return f"{self.email}"

                    @property
                    def name(self):
                        return f"{self.first_anme} {self.last_name}"




                # Creating the user and superuser

                class UserManager(BaseUserManager):
                    def get_object_by_public_id(self, public_id):
                        try:
                            instance = self.get(public_id=public_id)
                            return instance
                        except (ObjectDoesNotExist, ValueError, TypeError):
                            return Http404


                    def create_user(self, username, email, password=None, ***args, **kwargs):
                        """create and return a `user` with an email, phone number, username and password."""

                        if username is None:
                            raise TypeError('Users must have a username')

                        if email is None:
                            raise TypeError('User must have an email.')
                        
                        if password is None:
                            raise TypeError('User must have a password.')

                        user = self.model(username=username, email=self.normal(email), **kwargs)
                        user.set_password(password)
                        user.save(using=self._db)

                        return user

                    def create_supersuser(self, username, email, password, **kwargs):
                        """Create and return a `User` with superuser (admin) permissions """

                        if password is None:
                            raise typeError('superuser must have a password')

                        if email is None:
                            raise TypeError('Superuser must have an email.')

                        if username is None:
                            raise TypeError('Superuser must have a username.')

                        user = self.create_user(username, email, password, **kwargs)
                        user.is_superuser = True
                        user.is_staff = True
                        user.save(using=self._db)

                        return user

    4. et’s rewrite the apps.py file of the user. It contains the app configs that Django will use to 
        locate the application. Let’s also add a label for the application:

            core/user/apps.py

            from django.apps import AppConfig
            class UserConfig(AppConfig):
                default_auto_field = 'django.db.models.BigAutoField'
                name = '.core.user'
                label = 'core_user'


    5. t’s register the application now in the INSTALLED_APPS setting

                    ...
            'core',
            'core.user'
            ]

    6. We also need to tell Django to use this User model for the authentication user model. In the 
        settings.py file, add the following line:

        CoreRoot/settings.py
        AUTH_USER_MODEL = 'core_user.User'
        Great – we can now create the first migration for the user app:
        python manage.py makemigrations

        then run:

        python manage.py migrate


    7. writng User serializer, to handle complex data

         7.1 A serializer allows us to convert complex Django complex data structures such as QuerySet or model 
            instances into Python native objects that can be easily converted to JSON or XML format

            Django Rest Framework (DRF) provides a 
            serializers package you can use to write serializers and also validations when API calls are made 
            to an endpoint using this serializer.

            (a) pip install djangorestframework django-filter

                    requirements.txt:

                    Django==4.0.1
                    psycopg2-binary==2.9.3
                    djangorestframework==3.13.1
                    django-filter==21.1

            (b)  We are also adding django-filter for data filtering support. Let’s add rest_framework to 
                    the INSTALLED_APPS setting:
                    CoreRoot/settings.py
                    INSTALLED_APPS = [
                    ...
                    'rest_framework',
                    ]

            (c) In the core/user directory, create a file called serializers.py. This file will contain the 
                A serializer converts complex data types (like Django models) into JSON format for API responses, 
                and validates/converts JSON back into Python objects for database operations. 
                It's the bridge between your database models and API endpoints, handling data transformation
                 and validation automatically.
                
                core/user/serializers.py
                UserSerializer class:

                from rest_framework import serializers
                from core.models import User

                class UserSerializer(serializers.ModelSerializer):
                    id = serializers.UUIDField(source='public_id',
                    read_only=True, format="hex")
                    created = serializers.DateTimeField(read_only=True)
                    updated = serializers.DateTimeField(read_only=True)

                    class Meta: 
                        model = User
                        fields = ['id', 'username', 'first_name',
                            'last_name', 'bio', 'avatar', 'email',
                            'is_active', 'created', 'updated']
                        read_only_fields = ['is_active']

    8. Writing UserViewset
        As we know, Django at its core is based on the Model-View-Template (MVT) architecture. The 
        model communicates with the views (or controllers) and the template displays responses or redirects 
        requests to the views

        As we know, Django at its core is based on the Model-View-Template (MVT) architecture. The 
        model communicates with the views (or controllers) and the template displays responses or redirects 
        requests to the views

        a viewset is simply a class-based view that can 
        handle all the basic HTTP requests—GET, POST, PUT, DELETE, and PATCH—without hardcoding 
        any CRUD logic here.

        Let’s write the viewset. Inside the user directory, rename the view file viewsets.py and add 
        the following content:
        core/user/viewsets.py

        from rest_framework.permissions import AllowAny
        from rest_framework import viewsets
        from core.user.serializers import UserSerializer
        from core.user.models import User

        class UserViewSet(viewsets.ModelViewSet):
            http_method_names = ('patch', 'get')
            permission_classes = (AllowAny,)
            serializer_class = UserSerializer

            # gets the list of all users
            def get_queryset(self):
                if self.request.user.is_superuser:
                    return User.objects.all()
                return User.objects.exclude(is_superuser=True)

            # get one user
            # This method is called when 
            # a GET or PUT request is made on the /user/id/ endpoint, with id representing the ID of 
            # the user.

            def get_object(self):
                obj = User.objects.get_object_by_public_id(self.kwargs['pk'])
                self.check_object_permissions(self.request, obj)
                return obj

            # There we have the User viewset – but there is no endpoint yet to make it work. Well, let’s add a 
            # router now.

    9. Adding a router
        Routers allow you to quickly declare all of the common routes for a given controller; the next code 
        snippet shows a viewset to which we will be adding a router.
        At the root of the apps project (core), create a file named routers.py.
        And let’s add the code:

        core/router

        from rest_framework import routers
        
        from core.user.viewsets import UserViewSet

        router = routers.SimpleRouter()

        # ====================================
        # USER ROUTES
        # ====================================
        router.register(r'user', UserViewSet, basename='user')

        urlpatterns = [
            *router.urls,
        ]

        9.1 add the router path in coreRoot/urls.py

            rom django.contrib import admin
            from django.urls import path, include
            from core.routers import router

            urlpatterns = [
                path('admin/', admin.site.urls),
                path('api/', include(router.urls)),
            ]

        9.2 making permissions so tht not can edit someone's data
            change the permission on the permission_classes attribute in the 
            UserViewSet class:
            core/user/viewsets.py
            replace AllowAny with IsAuthenticated 

    10. Writing the user registration feature

        To make things simpler, if the registration of a user is successful, we will provide credentials, here 
        JWTs, so the user won’t have to log in again to start a session – a win for user experience.
        First, let’s install a package that will handle JWT authentication for us. 
        The djangorestframeworksimplejwt package is a JWT authentication plugin for DRF:

        pip install djangorestframework-simplejwt
        The package covers the most common use case of JWT
        register the app in INSTALLED_
        APPS and specify DEFAULT_AUTHENTICATION_CLASSES in the REST_FRAMEWORK dict:

        …
        # external packages apps
            'rest_framework',
            'rest_framework_simplejwt',
            'core',
            'core.user'
        ]
        ...
        REST_FRAMEWORK = {
            'DEFAULT_AUTHENTICATION_CLASSES': (
                'rest_framework_simplejwt.authentication
                 .JWTAuthentication',
            ),
            'DEFAULT_FILTER_BACKENDS':
                'django_filters.rest_framework.DjangoFilterBackend'],
        }

    create ne app called auth in the coer appear

    cd core && django-admin startapp auth:
        New-Item -Path "core/auth" -ItemType Directory -Force
        python -m django startapp auth core/auth

        core/auth/apps.py
        rewrite apps.py | label = 'core_auth' name = 'core.auth'

        coreRoot/settings.py installed apps add:
        'core.auth' 
        

    Create a Python package called serializers and another one called viewsets. 
    make sure that these new directories have an __init__.py file

    Inside the serializers directory, create a file called register.py
    core/auth/serializers/register.py

    from rest_framework import serializers
    from core.user.serializers import UserSerializer
    from core.user.models import User


    class RegisterSerializer(UserSerializer):
        """
            Registration serializer for requests and user creation
        """

        # making sure the password is at least 8 characters long and no longer
        # than 128 and cant be  read by the user

        password = serializers.CharFields(max_length=128, min_length=8, write_only=True, required=True)

        class Meta:
            model = User
            # list of all the fields that can be included in a response
            fields = ['id', 'bio', 'avatar', 'email', 'username', 'first_name',
                        'last_name', 'password']

        def create(self, validated_data):
            # Use the `create_user` method we wrote earlier for the UserManger to create 
            # a user.


            return User.objects.create_user(**validated_data)

            ==================================================================================


        11. Next, we can add the viewset and register it in the register.py file:
            core/auth/viewsets/register.py

            from rest_framework.response import Response
            from rest_framewor.viewsets import ViewSet
            from rest_framework.permissions import AllowAny
            from rest_framework import status
            from rest_frameworksimplejwt.tokens import RefreshToken
            from core.auth.serializers import RegisterSerializer

            class RegisterViewSet(ViewSet):
                serializer_class = RegisterSerializer
                permission_classes = (AllowAny,)
                http_method_names = ['post']

                def create(self, request, *args, **kwargs):
                    serializer = self.serializer_class(data=request.data)
                    serializer.is_valid(raise_exception=True)
                    user = serializer.save()
                    refresh = RefreshToken.for_user(user)
                    res = {
                        "refresh": str(refresh),
                        "access": str(refresh.access_token),
                    }

                    return Response ({
                        "user": serializer.data,
                        "refresh": res["refresh"],
                        "token": res["access"]
                    }, status=status.HTTP_201_CREATED)

    ==============================================================================================

        we are using attributes from the ViewSet class. We are also 
        rewriting the create method to add access and refresh tokens in the body of the response. The 
        djangorestframework-simplejwt package provides utilities we can use to directly generate 
        tokens. That’s what RefreshToken.for_user(user) does.


        12. final step – let’s register the viewset in the routers.py file:

            CORE/ROUTER.PY

            router.register(r'auth/register', RegisterViewSet, basename='auth-register')
            
    ========================================================================================
        NB dont forget to inport these in __init__.py
            from .register import RegisterViewSet

        Great! Let’s test the new endpoint with Insomnia. In the collection of requests for this project, create 
        a new POST request. The URL will be as follows: localhost:8000/api/auth/register/.
        As a body for the request, you can pass the following:
        {
        "username": "mouse21",
        "first_name": "Mickey",
        "last_name": "Mouse",
        "password": "12345678",
        "email": "mouse@yopmail.com"
        }

================================================================================
===============================================================================
    13. adding the login feature

        The login feature will require the email or the username with the password. Using the 
        djangorestframework-simplejwt package, which provides a serializer called 
        TokenObtainPairSerializer, we’ll write a serializer to check for user authentication but also 
        return a response containing access and refresh tokens. For this, we will rewrite the validate method 
        from the TokenObtainPairSerializer class. Inside the core/auth/serializers
        directory, create a new file called login.py (this file will contain LoginSerializer, a subclass 
        of TokenObtainPairSerializer):

        core/auth/serializers/login.py

        from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
        from rest_framework_simplejwt.settings import api_settings
        from django.contrib.auth.models import update_last_login
        from core.user.serializers import UserSerializer

        class LoginSerializer(TokenObtainPairSerializer):
            """
                Login serializer for requests and user authentication
            """

            def validate(self, attrs):
                data = super().validate(attrs)

                refresh = self.get_token(self.user)

                data['user'] = UserSerializer(self.user).data
                data['refresh'] = str(refresh)
                data['access'] = str(refresh.access_tpken)

                if api_settings.UPDATE_LAST_LOGIN:
                    update_last_login(None, self.user)

                return data

        ==========================================================================================
        That’s why super is helpful here. It’s a built-in method in Python that returns 
        a temporary object that can be used to access the class methods of the base class.
        ==========================================================================================

        core/auth/serializers/__init__.py

        code:
            from .register import RegisterSerializer
            from .login import LoginSerializer

        ==========================================================================================

        14. The next step is to add the viewset. We’ll call this viewset LoginViewset. As we are not directly 
            teracting with a model here, we’ll just be using the viewsets.ViewSet class:

            core/auth/viewsets/login.py

        code:
            from rest_framework.response import Response
            from rest_framework.viewsets import ViewSet
            from rest_framework.permissions import AllowAny
            from rest_framework import status
            from rest_framework_simplejwt.exceptions import TokenError, InvalidToken    
            from core.auth.serializers import LoginSerializer

            class LoginViewSet(ViewSet):
                serializer_class = LoginSerializer
                permission_classes = (AllowAny,)
                http_method_names = ['post']

                def create(self, request, *args, **kwargs):
                    serializer = self.serializer_class(data=request.data)
                    try:
                        serializer.is_valid(raise_exception=True)

                    except TokenError as e:
                        raise InvalidToken(e.args[0])

                    return Response(serializer.validated_data, status=status.HTTP_200_OK)

            =================================================================================

         14.   Add the viewset to the __init__.py file of the viewsets directory:
         code:
            from .register import RegisterViewSet
            from .login import LoginViewSet
        ======================================================================================

        We can now import it and register it in the routers.py file:
        core/routers.py
        code:
            router.register(r'auth/login', LoginViewSet, basename='auth-login')
            
    =========================================================================================

        14. Refresh logic
        In auth/viewsets, add a new file called refresh.py:
        core/auth/viewsets/refresh.py

        code:
            from rest_framework.response import Response
            from rest_framework_simplejwt.views import TokenRefreshView
            from rest_framework.permissions import AllowAny
            from rest_framework import status
            from rest_framework import viewsets
            from rest_framework_simplejwt.exceptions import TokenBackendError, InvalidToken

            class RefreshViewSet(viewsets.ViewSet, TokenRefreshView):
                permission_casses = (AllowAny,)
                http_method_names = ['post']

                def create(self, request, *args, **kwargs):
                    serializer = self.get_serializer(data=request.data)

                    try:
                        serializer.is_valid(raise_exxception=True)

                    except TokenError as e:
                        raise InvalidToken(e.args[0])

                    return Response(serializer.validated_data, status=status.HTTP_200_OK)

    ===========================================================================================
    Now add the class in the __init__.py file.
    from .register import RegisterViewSet
    from .login import LoginViewSet
    from .refresh import RefreshViewSet
    
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    And now register it in the routers.py file
    core/routers.py
    code:
        from core.auth.viewsets import RegisterViewSet,
        LoginViewSet, RefreshViewSet
        ...
        router.register(r'auth/refresh', RefreshViewSet,
        basename='auth-refresh')
----------------------------------------------------------------------------------------------------------
Summary
In this chapter, we learned how to write an authentication system based on JWT for a Django application 
using DRF and djangorestframework-simplejwt. We also learned how to extend classes 
and rewrite the functions.
In the next chapter, we’ll add the posts feature. Our users will be able to create a post that can be 
viewed and liked by other users.
Questions
1. What is a JWT?
2. What is Django Rest Framework?
3. What is a model?
4. What is a serializer?
5. What is a viewset?
6. What is a router?
7. What is the usage of a refresh token?

_________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________


==============================================================================================================
3. SOCIAL MEDIA POST MANAGEMENT
==============================================================================================================

        3.1     Create post models, using abstraction

            For the sake of the don’t repeat yourself (DRY) principle, we will use abstract model classes.
            An abstract class can be considered a blueprint for other classes. It usually contains a set of methods 
            or attributes that must be created within any child classes built from the abstract class.

            core/abstract/models.py

            code:
                from django.db import models
                import uuid
                from django.core.exceptions import ObjectDoesNotExist
                from django.http import Http404


                class AbstractManager(models.Manager):
                    def get_object_by_public_id(self, public_id):
                        try:
                            instance = self.get(public_id=public_id)
                            return instance
                        except (ObjectDoesNotExist, ValueError, TypeError):
                            raise Http404


                class AbstractModel(models.Model):
                    public_id = models.UUIDField(db_index=True, unique=True, default=uuid.uuid4, editable=False)
                    created = models.DateTimeField(auto_now_add=True)
                    updated = models.DateTimeField(auto_now=True)

                    objects = AbstractManager()
                    
                    class Meta:
                        abstract = True

        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    Now that we have this class, let’s make a quick refactor on the User model:
                    First, let’s remove the get_object_by_public_id method to retrieve an object via public_id, 
                    and let’s subclass UserManager:

                    core/user/models.py
                       new code:

                            from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
                            from django.db import models

                            from core.abstract.models import AbstractModel, AbstractManager


                            class UserManager(BaseUserManager, AbstractManager):

                                def create_user(self, username, email, password=None, **kwargs):
                                    """Create and return a `User` with an email, phone number, username and password."""
                                    if username is None:
                                        raise TypeError('Users must have a username.')
                                    if email is None:
                                        raise TypeError('Users must have an email.')
                                    if password is None:
                                        raise TypeError('User must have an email.')

                                    user = self.model(username=username, email=self.normalize_email(email), **kwargs)
                                    user.set_password(password)
                                    user.save(using=self._db)

                                    return user

                                def create_superuser(self, username, email, password, **kwargs):
                                    """
                                    Create and return a `User` with superuser (admin) permissions.
                                    """
                                    if password is None:
                                        raise TypeError('Superusers must have a password.')
                                    if email is None:
                                        raise TypeError('Superusers must have an email.')
                                    if username is None:
                                        raise TypeError('Superusers must have an username.')

                                    user = self.create_user(username, email, password, **kwargs)
                                    user.is_superuser = True
                                    user.is_staff = True
                                    user.save(using=self._db)

                                    return user


                            class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
                                username = models.CharField(db_index=True, max_length=255, unique=True)
                                first_name = models.CharField(max_length=255)
                                last_name = models.CharField(max_length=255)

                                email = models.EmailField(db_index=True, unique=True)
                                is_active = models.BooleanField(default=True)
                                is_superuser = models.BooleanField(default=False)

                                bio = models.TextField(null=True)
                                avatar = models.ImageField(null=True)

                                posts_liked = models.ManyToManyField(
                                    "core_post.Post",
                                    related_name="liked_by"
                                )

                                USERNAME_FIELD = 'email'
                                REQUIRED_FIELDS = ['username']

                                objects = UserManager()

                                def __str__(self):
                                    return f"{self.email}"

                                @property
                                def name(self):
                                    return f"{self.first_name} {self.last_name}"

                                def like(self, post):
                                    """Like `post` if it hasn't been done yet"""
                                    return self.posts_liked.add(post)

                                def remove_like(self, post):
                                    """Remove a like from a `post`"""
                                    return self.posts_liked.remove(post)

                                def has_liked(self, post):
                                    """Return True if the user has liked a `post`; else False"""
                                    return self.posts_liked.filter(pk=post.pk).exists()
                    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        
                        Writing the AbstractSerializer

                        core/abstract/serializers.py

                        code:
                            from rest_framework import serializers

                            class AbstractSerializer(serializers.ModelSerializer):
                                id = serializers.UUIDField(source='public_id', read_only=True, format='hex')
                                created = serializers.DateTimeField(read_only=True)
                                updated = serializers.DateTimeField(read_only=True)

                    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                            Writing the AbstractViewSet
                            core/abstract/viewsets.py
                            code:
                                from rest_framework import viewsets
                                from rest_framework import filters

                                class AbstractViewSet(viewsets.ModelViewSet):
                                    filter_backends = [filters.OrderingFilter]
                                    ordering_fields = ['updated', 'created']
                                    ordering = ['-updated',]
                    ________________________________________________________________________________________
                    As you can see, we have the following attributes:
                    • filter_backends: This sets the default filter backend.
                    • ordering_fields: This list contains the fields that can be used as ordering parameters 
                    when making a request.
                    • ordering: This will tell Django REST in which order to send many objects as a response. In 
                    this case, all the responses will be ordered by the most recently updated.
                    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=+++++
                    The next step is to add the AbstractViewSet class to the code where ModelViewSets
                    is actually called. Go to core/user/viewsets.py and subclass UserViewSet with the 
                    AbstractViewSet class:

                    core/user/viewsets.py
                    …
                    from core.abstract.viewsets import AbstractViewSet
                    from core.user.serializers import UserSerializer
                    from core.user.models import User
                    class UserViewSet(AbstractViewSet):
        ______________________________________________________________________________________


                3.2    writting post model
                        code:

                from django.apps import AppConfig


                class PostConfig(AppConfig):
                    default_auto_field = 'django.db.models.BigAutoField'
                    name = 'core.post'
                    label = 'core_post'
        ______________________________________________________________________________________

            core/post/models.py
            code: 
                from django.db import models
                from core.abstract.models import AbstractModel, AbstractManager

                class PostManager(AbstractManager):
                    pass

                class Post(AbstractModel):
                    author = models.ForeignKey(to="core_user.User", on_delete=models.CASCADE)
                    body = models.TextField()
                    edited = models.BooleanField(default=False)

                    objects = PostManager()
                    def __str__(self):
                        return f"{self.author.name}"
                    
                    class Meta:
                        db_table = "core.post"

            ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            Add the newly created application to the INSTALLED_APPS list:
            CoreRoot/settings.py

                …
                'core.post'
                …
            create the migrations for the newly added application:
            ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

            Then, let’s play with the Django shell by starting it with the python manage.py 
            shell command:

            _______________________________________________________________

        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            3.3 Writing the Post serializer

            The Post serializer will contain the fields needed to create a post when making a request on the 
            endpoint. Let’s add the feature for the post creation first.

            core/post/serializers.py
            code:
                from rest_framework import serializers
                from rest_framework.exceptions import ValidationError
                from core.abstract.serializers import AbstractSerializer    
                from core.post.models import Post
                from core.user.models import User

                class PostSerializer(AbstractSerializer):
                    author = serializers.SlugRelatedield(
                        queryset=User.objects.all(), slug_field='public_id'
                    )

                    def validate_author(self, value):
                        if self.context["request"] .user != value:
                            raise ValidationError("can't create a post for another user.")

                        return value

                    class Meta:
                        model = Post
                        # List of all the fields that can be included in a request
                        fields = ['id', 'author', 'body', 'edited', 'created', 'updated']
                        read_only_fields = ['edited']

====================================================================================================
             3.4 Writing Post viewsets
            For the following endpoint, we’ll only be allowing the POST and GET methods. This will help us have 
            the basic features working first.
            The code should follow these rules:
                • Only authenticated users can create posts
                • Only authenticated users can read posts
                • Only GET and POST methods are allowed

                core/post/viewsets.py
                CODE:
                    from rest_framework.permissions import IsAuthenticated
                    from core.abstract.viewsets import AbstractViewSet
                    from core.post.models import post
                    from core.post.serializers import PostSerializer

                    class PostViewSet(AbstractViewSet):
                        http_method_names = ('post', 'get')
                        permissions_classes = (IsAuthenticated,)
                        serializer_class = PostSerializer

                        def get_queryset(self):
                            return Post.objects.all()

                        def get_object(self):
                            obj = Post.objects.get_object_by_public_id(
                                self.kwargs['pk'])

                            self.check_object_permissions(self.request, obj)
                            return obj

                        def create(self, request, *args, **kwargs):
                            serializer = self.get_serializer(data=request.data)
                            serializer.is_valid(raise_exception=True)
                            self.perform_create(serializer)
                            return Response(serializer.data, status=status.HTTP_201_CREATED)

=================================================================================
                3.5 core/routers.py
                ADDING ROUTER FOR POSTS
                code:
                    from core.post.viewsets import PostViewSet

                    router.register(r'post', PostViewSet, basename='post')


        =========================================================================

        3.6 make the pagination to 15 per request so that api dont slow down when have many posts

        CoreRoot/settings.py
        REST_FRAMEWORK = {
        …
        'DEFAULT_PAGINATION_CLASS':
        'rest_framework.pagination.LimitOffsetPagination',
        'PAGE_SIZE': 15,
        }
        --------------------------------------------------------------

        3.7 Rewriting the Post serialized object

        it’ll be more practical to have the name of the author in the response as well. Let’s rewrite a 
        serializer method that can help modify the response object.

        Actually, the author field accepts public_id and returns public_id. While it does the 
        work, it can be a little bit difficult to identify the user. This will cause it to make a request again with 
        public_id of the user to get the pieces of information about the user.
        The to_representation() method takes the object instance that requires serialization and 
        returns a primitive representation. This usually means returning a structure of built-in Python data 
        types. The exact types that can be handled depend on the render classes you configure for your API.
        Inside post/serializers.py, add a new method called to_represenation():
        core/post/serializers.py

        def to_representtion(self, instance):
            rep = super().to_represenration(instance)
            author = User.objects.get_object_by_publi_id(rep["author"])
            rep["author"] = UserSerializer(author).data
            return rep
=========================================================================================

        3.8 Adding permissions

        We want anonymous users to be able to read the posts on the API without necessarily being 
        authenticated. While it’s true that there is the AllowAny permission, it’ll surely conflict with the 
        IsAuthenticated permission.
        Thus, we need to write a custom permission.
        Inside the authentication directory, create a file called permissions, and add the 
        following content:

        core/post/viewsets.py

        code:

            from rest_framework.permissions import BasePermission, SAFE_METHODS

            class UserPermission(BasePermission):

                def has_object_permission(self, request, view, obj):
                    if request.user.is_anonymous:
                        return request.method in SAFE_METHODS

                    if view.basename in ["post"]:
                        return bool(request.user and request.user.is_authenticated)
                    
                return False

                def has_permission(self, request, view):
                    if view.basename in ["post"]:
                        if request.user.is_anonymous:
                            return request.method in SAFE_METHODS

                        return bool(request.user and request.user.is_authenticated)

                    return False
============================================================================================


         3.9   Deleting and updating posts

         Deleting and updating articles are also part of the features of posts. To add these functionalities, we 
        don’t need to write a serializer or a viewset, as the methods for deletion (destroy()), and updating 
        (update()) are already available by default in the ViewSet class. We will just rewrite the update
        method on PostSerializer to ensure that the edited field is set to True when modifying a post.

            core/post/viesets

            …
            class PostViewSet(AbstractViewSet):
            http_method_names = ('post', 'get', 'put', 'delete')
            …

=================================================================================

            3.10 core/post/serializers.py

            Before going in, let’s rewrite the update method in PostSerializer. We actually have a field 
            called edited in the Post model. This field will tell us whether the post has been edited:

            …
            class PostSerializer(AbstractSerializer):
            …
                def update(self, instance, validated_data):
                    if not instance.edited:
                         validated_data['edited'] = True
                    instance = super().update(instance, validated_data)
                    return instance

=================================================================================================

              3.11  Adding the Like feature
                    We’ll do this in four steps:
                        10. Add a new posts_liked field to the User model.
                        11. Write methods on the User model to like and remove a like from a post. We’ll also add a 
                        method to check whether the user has liked a post.
                        12. Add likes_count and has_liked to PostSerializer.
                        13. Add endpoints to like and dislike a post.
                        Great! Let’s start by adding the new fields to the User model.

                        • A user can like many posts
                        • A post can be liked by many users
                        This kind of relationship sounds familiar? It is a many-to-many relationship.

                        Open the /core/user/models.
                        py file and add a new field to the User model:

                        class User(AbstractModel, AbstractBaseUser, PermissionsMixin):
                        ...
                        posts_liked = models.ManyToManyField(
                            "core_post.Post",
                            related_name="liked_by"
                            )
                        ...
=========================================================================

            3.12 Adding the like, remove_like, and has_liked methods

            Before writing these methods, let’s describe the purpose of each new method:
            • The like() method: This is used for liking a post if it hasn’t been done yet. For this, we’ll use 
            the add() method from the models. We’ll use ManyToManyField to link a post to a user.
            • The remove_like() method: This is used for removing a like from a post. For this, we’ll 
            use the remove method from the models. We’ll use ManyToManyField to unlink a post 
            from a user.
            • The has_liked() method: This is used for returning True if the user has liked a post, 
            else False.

                core/user/models.py
            def like(self, post):
                """Like `post` if it hasn't been done yet"""
                return self.posts_liked.add(post)

            def remove_like(self, post):
                """Remove a like from a `post`"""
                return self.posts_liked.remove(post)

            def has_liked(self, post):
                """Return True if the user has liked a `post`; else False"""
                return self.posts_liked.filter(pk=post.pk).exists()

=============================================================================

                3.13 Adding the likes_count and has_liked fields to PostSerialize

                Instead of adding fields such as likes_count in the Post model and generating more fields in 
                the database, we can directly manage it on PostSerializer. The Serializer class in Django 
                provides ways to create the write_only values that will be sent on the response.

                Core/post/serializers.py
            ...
            class PostSerializer(AbstractSerializer):
            ...
            
                liked = serializers.SerializerMethodField()
                likes_count = serializers.SerializerMethodField()

                def get_liked(self, instance):
                    request = self.context.get('request', None)

                    if request is None or request.user.is_anonymous:
                        return False

                    return request.user.has_like(instance)

                def get_likes_count(self, instance):
                    return instance.liked_by.count()
==============================================================================

                3.14    we can now add the endpoints needed to PostViewSet
                         to like or dislike an article.

                         Adding like and dislike actions to PostViewSet

                         DRF provides a decorator called action. This decorator helps make methods on a ViewSet class 
                        routable. The action decorator takes two arguments:
                        • detail: If this argument is set to True, the route to this action will require a resource lookup 
                        field; in most cases, this will be the ID of the resource
                        • methods: This is a list of the methods accepted by the action

                        
                    @action(methods=['post'], detail=True)
                    def like(self, request, *args, **kwargs):
                        post = self.get_object()
                        user = self.request.user

                        user.like(post)

                        serializer = self.serializer_class(post)

                        return Response(serializer.data, status=status.HTTP_200_OK)

                    @action(methods=['post'], detail=True)
                    def remove_like(self, request, *args, **kwargs):
                        post = self.get_object()
                        user = self.request.user

                        user.remove_like(post)

                        serializer = self.serializer_class(post)

                        return Response(serializer.data, status=status.HTTP_200_OK)

======================================================================================================
        new routes for this resource, and then, you can do the following:
        1. Like a post with the following endpoint: api/post/post_pk/like/.
        2. Remove the like from a post with the following endpoint: api/post/post_pk/remove_
        like/.

====================================================================================================
========================================================================

4 adding comments to social media Posts

========================================================================

structurre of the comments":
1. public_id: starting
2. body: starting
3. author: ForeignKey(fk)
4. post: fk
5. edited: boolean
6. created: DateTime
7. updated: datetime.
